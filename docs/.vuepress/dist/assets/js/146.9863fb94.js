(window.webpackJsonp=window.webpackJsonp||[]).push([[146],{302:function(n,t,e){"use strict";e.r(t);var r=e(0),a=Object(r.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"类型声明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型声明","aria-hidden":"true"}},[n._v("#")]),n._v(" 类型声明")]),n._v(" "),e("p",[n._v("声明变量和声明函数的参数时可以同时声明变量类型，函数参数如果不显示声明类型则默认是object类型")]),n._v(" "),e("p",[n._v("例如：")]),n._v(" "),e("pre",[e("code",[n._v('let a: string = "123"\nvar b: G1                          -- G1是某个record类型\nlet b: int | string | Person     --   Person是某个record类型，这种声明表示b是int或string或Person类型，也就是union类型\nlet c ?: int                       --  这种表示声明的变量c是int或nil类型的，相当于 int | nil的union类型\n\nlet function add(a: number, b: number, c ?: Array<number>)\n    return a + b\nend\n')])]),n._v(" "),e("p",[n._v("声明类型时也可以声明函数类型，函数的签名类型语法是 (ArgTypeName1, … ) => RetTypeName")]),n._v(" "),e("p",[n._v("例如")]),n._v(" "),e("pre",[e("code",[n._v("let a: (int, int, int) => string\n")])]),n._v(" "),e("p",[n._v("还可以将变量或者函数参数的类型声明为Function，表示这个变量/参数的类型是函数，能接受任何函数类型的值，不论参数数量，参数类型和返回值类型。\n例如")]),n._v(" "),e("pre",[e("code",[n._v("let function add(a: number, b: number)\n    return a + b\nend\nlet add2: Function = add\nlet r = add2('123')    -- 这段代码编译期类型没问题，但是运行时会报类型错误\n")])])])},[],!1,null,null,null);t.default=a.exports}}]);