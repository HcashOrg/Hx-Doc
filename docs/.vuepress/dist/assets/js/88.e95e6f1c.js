(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{336:function(e,t,r){"use strict";r.r(t);var s=r(0),n=Object(s.a)({},function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"可共识随机数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可共识随机数","aria-hidden":"true"}},[e._v("#")]),e._v(" 可共识随机数")]),e._v(" "),r("p",[e._v("智能合约具有获取可共识的随机数的需求，为了生成可共识的随机数，输入必须是链相关数据。这里提供了两种随机数获取方法:")]),e._v(" "),r("p",[e._v("简单随机数：合约中直接调用一个接口获取一个随机数,提供基于当前随机种子的随机数。")]),e._v(" "),r("p",[e._v("复杂随机数：用户在合约中指定一组连续的块，系统以该组块的prev_secret 作为输入，产生随机数。用户可以指定未产生的一组块记录在合约中，在该组块被产生后，随机数被确定。")]),e._v(" "),r("p",[e._v("用户能够在合约中直接调用接口获取简单随机数。此种方式，对于一次合约调用，在执行结果利益相关方恰好是当前产块人时，存在产块人根据随机\n数结果以及自身利益选择不打包该调用的可能性。")]),e._v(" "),r("p",[e._v("在希望避免这种可能的情况时，可以采用复杂随机数。复杂随机数以连续块的 prev_secret 作为输入，产块者若想产生对自身有利的随机数，需要根\n据组内其他块的prev_secret,调整当前块的prev_secret,但是prev_secret是在前一轮产块时就已经确定的，无法修改，即产块者无法控制随机数的产生")])])},[],!1,null,null,null);t.default=n.exports}}]);