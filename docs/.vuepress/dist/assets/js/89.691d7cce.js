(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{339:function(a,e,r){"use strict";r.r(e);var t=r(0),s=Object(t.a)({},function(){var a=this,e=a.$createElement,r=a._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"虚拟机"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机","aria-hidden":"true"}},[a._v("#")]),a._v(" 虚拟机")]),a._v(" "),r("p",[a._v("使用一种图灵完备并为区块链智能合约定制设计的字节码规范作为智能合约虚拟机的实现规范。提供静态类型的高级编程语言比如 C#，Java,\nTypeScript 等的编译器实现从高级语言生成智能合约字节码。")]),a._v(" "),r("h2",{attrs:{id:"智能合约虚拟机："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约虚拟机：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约虚拟机：")]),a._v(" "),r("p",[a._v("智能合约虚拟机实现为一种图灵完备的字节码虚拟机，做到运行时具有确定性，执行逻辑可控性，状态变化可监控。")]),a._v(" "),r("h2",{attrs:{id:"智能合约语言："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约语言：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约语言：")]),a._v(" "),r("p",[a._v("使用现有编程语言比如 C#，Java, TypeScript 等流行的编程语言的主要特性的子集作为智能合约的高级编程语言，编译为符合智能合约字节码规范的字节码，提供给创建智能合约的用户使用。")]),a._v(" "),r("h2",{attrs:{id:"智能合约的内置库："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约的内置库：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约的内置库：")]),a._v(" "),r("p",[a._v("智能合约的内置库包含一些常用数值操作，字符串操作等的基本库，以及一些链上查询，交易等的内置函数库，在写智能合约时可以调用内置库。")]),a._v(" "),r("h2",{attrs:{id:"智能合约的互相调用："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约的互相调用：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约的互相调用：")]),a._v(" "),r("p",[a._v("智能合约部署到链上后，除了可以被用户直接调用或者存取资产，还可以调用其他智能合约/内置原生合约，或被其他智能合约调用。部分功能逻辑可以通过智能合约实现并部署在链上，作为第三方库被链上其他智能合约使用，起到扩展区块链的功能的作用。")]),a._v(" "),r("h2",{attrs:{id:"智能合约的功能范围和限制："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约的功能范围和限制：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约的功能范围和限制：")]),a._v(" "),r("p",[a._v("智能合约可以用图灵完备的编程语言编写业务逻辑，可以查询链上数据，可以确定性存取本合约的状态 storage，可以调用其他智能合约/原生合约，可以输出返回信息给调用者。限制：不能读取链外数据；不能非确定性产生各节点不一致的逻辑；执行指令数和使用内存空间量受区块链控制；区块链可以随时立刻终止智能合约的执行，比如在合约执行费用超预算时。")]),a._v(" "),r("h2",{attrs:{id:"智能合约的状态存储："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约的状态存储：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约的状态存储：")]),a._v(" "),r("p",[a._v("每个智能合约有一个独立的状态存储空间，称作 storage。storage 的存储格式是非结构化的数据结构。链上存储智能合约的 storage 的变化，而不是每次完整存储最新 storage 到链上。比如在一次合约调用中，将合约 storage从 {“name”: “chain” } 修改为 { “name”: “chain”, “count”:123 }，链上只记录变化的部分 { “count”: 123 }，并且计算合约调用手续费时，存储部分收费也只计算变化的部分的大小而不是完整 storage 的大小。因此即使一个智能合约的状态存储空间较大，只要每次调用合约产生的变化量不大，链上数据增量和手续费也不高。")]),a._v(" "),r("h2",{attrs:{id:"智能合约的状态查询："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#智能合约的状态查询：","aria-hidden":"true"}},[a._v("#")]),a._v(" 智能合约的状态查询：")]),a._v(" "),r("p",[a._v("智能合约可以直接查询本合约的 storage 的部分值，也可以通过类 SQL 的编程语言取出嵌套数据结构中的部分数据。在智能合约的 storage 较大的时候，可以通过这种方式减少数据加载量提高查询速度，避免全表扫描，提高智能合约的数据存取部分的性能上限。")]),a._v(" "),r("p",[a._v("比如：某智能合约的 storage 结构类似")]),a._v(" "),r("pre",[r("code",[a._v("{\n“name”: “blockchain”,\n“userBalances”: [\n{ “userAddress”: “a”, “amount”: 10000, “freeze”:\nfalse },\n{ “userAddress”: “b”, “amount”: 20000, “freeze”:\ntrue },{ “userAddress”: “c”, “amount”: 30000, “freeze”:\nfalse },\n……. \n")])]),a._v(" "),r("p",[a._v("更多数据，比如几十万条记录\n]\n}\n可 以 使 用 类 似 "),r("code",[a._v("var freezedUsers = storage.query(“selectuserBalance.userAddress from userBalances as userBalance wherefreeze=true”)")]),a._v(" 这样的类 SQL 语法查询出本智能合约中所有冻结账户的用户地址，数据读写量大大减少，并且避免了全表扫描，可以满足在智能合约中存储较多数据但是每次读取量不大的业务场景，比如在智能合约中实现简单 push 交易所，实现智能合约资产，实现合约保险等。")])])},[],!1,null,null,null);e.default=s.exports}}]);