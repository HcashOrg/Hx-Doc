(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{197:function(n,t,e){"use strict";e.r(t);var r=e(0),a=Object(r.a)({},function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"gsharpc支持的c-编程语言子集"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#gsharpc支持的c-编程语言子集","aria-hidden":"true"}},[n._v("#")]),n._v(" gsharpc支持的C#编程语言子集")]),n._v(" "),e("p",[n._v("gsharpc只支持使用C#编程语言的一个子集来编写智能合约，包括了大部分C#的语法和控制结构，另外提供了类似uvm语言的类库的内置函数和类型。本文描述支持的C#子集的语法和类库")]),n._v(" "),e("h1",{attrs:{id:"c-的基本语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-的基本语法","aria-hidden":"true"}},[n._v("#")]),n._v(" C#的基本语法")]),n._v(" "),e("p",[n._v("参考微软官方文档 https://docs.microsoft.com/zh-cn/dotnet/articles/csharp/programming-guide/index\n本文之后会描述哪些特性是支持的")]),n._v(" "),e("h1",{attrs:{id:"c-版智能合约格式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-版智能合约格式","aria-hidden":"true"}},[n._v("#")]),n._v(" C#版智能合约格式")]),n._v(" "),e("p",[n._v("格式例如：")]),n._v(" "),e("pre",[e("code",[n._v('using static UVMCoreLib.UVMCoreFuncs;  // 引用内置全局函数库\nusing UVMCoreLib; // 引用其他内置库\n\npublic class Storage  // 这里定义合约的storage的类型\n{\n    public string Name { get; set; } // 定义storage的属性\n    public int Age { get; set; }\n    public string Country; // 用C#的field语法也可以定义storage属性\n    public bool IsMale { get; set; }\n    // 这里定义string数组类型的storage属性，因为uvm的数组和C#数组用法不兼容，所以用UVMArray来代币uvm中的数组类型\n    public UVMArray<string> ArrayDemo { get; set; } \n}\n\n// 这是可选的，实现IUVMEventEmitter接口的类型定义了本合约中有哪些event事件需要抛出\npublic class MyEventEmitteer : IUVMEventEmitter\n{\n    // "Emit"开头的静态方法，且只有一个字符串参数，返回值是void的，代表一种event事件，事件名称是方法名去掉"Emit"前缀\n    public static void EmitHello(string eventArg)\n    {\n         // 这里抛出event事件的方法体，直接C#项目中调试的时候可以用来调试，编译到uvm字节码的时候不包括这里的方法体\n        Console.WriteLine("event Hello emited, arg is " + eventArg);\n    }\n    public static void EmitHello2(string eventArg)\n    {\n        Console.WriteLine("event Hello2 emited, arg is " + eventArg);\n    }\n}\n\n// 这里是具体的合约类型，类型名自定义，需要符合C#的类型名规范，需要继承UVMContract<T>类型，其中T类型表示合约的storage类型\npublic class MyContract : UVMContract<Storage>\n{\n    // 合约的构造函数，这个函数内不要添加方法体代码，增加了在编译到uvm字节码后也不会包含，只有C#项目直接运行时起效\n    public MyContract() : base(new Storage())\n    {\n    }\n\n    // 必须实现的init方法，合约注册的时候初始化合约的函数\n    public override void init()\n    {\n        print("contract initing"); // 这里调用的print函数就是文件头using static引用的UVMCoreLib.UVMCoreFuncs中的静态方法\n        this.storage.Age = 100; // 合约的storage的属性都需要在init方法中初始化，否则无法成功注册合约到链上\n        this.storage.Country = "China";\n        this.storage.Name = "C#";\n        this.storage.IsMale = true;\n        this.storage.ArrayDemo = UVMArray<string>.Create(); // 这里是创建一个空的元素类型是string类型的uvm数组\n        this.storage.ArrayDemo.Add("hello"); // 给uvm数组中添加一个元素"hello"\n        pprint(this);\n        print("this is contract init api");\n    }\n\n    // 这里是定义了一个合约中的API，接受一个string类型参数，返回一个string类型对象\n    public string GetAge(string arg)\n    {\n        print("this is contract getAge api");\n        return "" + this.storage.Age; // 返回两个对象连接后的字符串，字符串和其他类型用+连接的时候，会自动调用tostring转换成字符串连接\n    }\n\n    // 定义一个返回string类型对象的offline接口，offline接口在链上通过call_contract_offline命令调用，调用操作不上链，主要用来定义查询类函数\n    public string OfflineGetAge(string arg)\n    {\n        print("this is contract OfflineGetAge api");\n        print("age is " + this.storage.Age); // 这里this.storage读取了本合约的storage对象\n        return "" + this.storage.Age;\n    }\n\n    public void TestHello(string arg)\n    {\n        print("this is contract hello api with argument " + arg); // 这里访问了合约API的参数arg\n    }\n}\n\n// 除了合约类型，storage类型外，还需要额外定义一个包含Main方法的类型，作为合约的加载入口\npublic class ExampleLibClass\n{\n    // 非静态的Main方法作为合约的加载入口，返回类型是定义的合约类型，这个方法会被调用用来加载合约，返回的合约对象就是本文件定义的合约\n    public MyContract Main()\n    {\n        print("start of demo C# contract");\n        var contract = new MyContract();\n        print("end main");\n        return contract; // 必须返回一个合约对象\n    }\n}\n')])]),n._v(" "),e("h1",{attrs:{id:"内置库"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内置库","aria-hidden":"true"}},[n._v("#")]),n._v(" 内置库")]),n._v(" "),e("p",[n._v("通过 importModule(string moduleName) 函数可以引用内置模块库，比如 string, table, json模块等")]),n._v(" "),e("p",[n._v("内置了一些全局函数，列表如下：")]),n._v(" "),e("pre",[e("code",[n._v("bool and(bool a, bool b) 布尔与\nbool or(bool a, bool b) 布尔或\nnumber div(number a, number b) 浮点除法\nint idiv(number a, number b) 整数除法\nnumber neg(number a) 数值取反\nbool not(bool a) 布尔取反\nvoid print(object obj) 输出对象字符串化后结果\nstring tostring(object obj) 把对象转成字符串返回\nstring tojsonstring(object obj) 把对象转成json字符串返回\nvoid pprint(object obj) 把对象json字符串化后的结果输出\nint? tointeger(object obj) 把对象转换成整数返回，如果转换失败，返回null\nfloat? tonumber(object obj) 把对象转换成浮点数返回，如果转换失败，返回null\nT importContract<T>(string contractName) 引用其他合约，返回合约的对象，调用时需要制定合约的接口类型T\nT importModule<T>(string moduleName) 引用内置模块，返回模块的对象，调用时需要制定模块的类型\nvoid Debug() 调试用，用来输出模拟C#的evaluate stack\nstring Type(object value) 返回参数的类型的字符串\nvoid Exit(int exitCode) 用某个错误码报错退出调用\nvoid Error(string errorMsg) 携带某个错误信息字符串退出调用\nUVMMap<object> getmetatable(UVMTable table) 获取table的元表\nvoid setmetatable(UVMTable table, UVMTable metatable) 设置table的元表\nbool toboolean(object value) 把参数转换成布尔类型\nUVMTable totable(object value) 把参数转换成table类型，如果原来就是table类型，保持不变，否则返回null\nbool rawequal(object a, object b) 比较a和b两个对象是否相等\nlong rawlen(object value) 获取参数的长度（数组部分长度或字符串长度）\nobject rawget(object table, object key) 获取table的某个属性key\nvoid rawset(object table, object key, object value) 设置table的某个属性key值为value\nint transfer_from_contract_to_address(string address,\n  string assetName, long amount) 从合约转账到地址\nvoid set_mock_contract_balance_amount(string contractAddress, \n  string assetName, long amount) 模拟设置合约的余额，方便测试用\nlong get_contract_balance_amount(string contractAddress, string assetName) 获取合约的余额\nlong get_chain_now() 获取链上时间\nlong get_chain_random() 获取链上随机数\nlong get_header_block_num() 获取链上块号\nlong get_waited(long num) 获取第num个块上某个数字（可用未来数来模拟随机数）\nstring get_current_contract_address() 获取当前合约地址\nstring caller() 当前调用者的公钥\nstring caller_address() 当前调用者的地址\nlong get_transaction_fee() 获取交易手续费，10万精度\nlong transfer_from_contract_to_public_account(string to_account_name, string assertName,\n  long amount) 从合约转账到账户\n")])]),n._v(" "),e("h1",{attrs:{id:"支持的c-语法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#支持的c-语法","aria-hidden":"true"}},[n._v("#")]),n._v(" 支持的C#语法")]),n._v(" "),e("pre",[e("code",[n._v("类型定义和使用\n\n类型的属性和字段定义和使用\n\n类型的成员方法，静态方法定义和使用\n\n函数调用，函数参数，函数返回值的支持\n\n类型继承\n\n数值操作\n\n字符串连接（通过+连接的方式只支持2个对象进行字符串连接）\n\n布尔操作\n\n变量声明和赋值\n\nthis对象的使用\n\nif/else if/else控制流结构\n\nfor控制流结构\n\nuvm的Map和Array类型的创建和修改\n\nuvm的Map和Array类型的遍历（迭代器遍历）\n\nwhile控制流结构\n\ncontinue和break语句的支持\n\n比较操作符\n\n内置函数和库的调用\n\nnew 新类型\n\nemit event\n\n引用内置模块\n\n引用合约\n")])])])},[],!1,null,null,null);t.default=a.exports}}]);