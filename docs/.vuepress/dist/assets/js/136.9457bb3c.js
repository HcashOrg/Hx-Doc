(window.webpackJsonp=window.webpackJsonp||[]).push([[136],{335:function(a,e,n){"use strict";n.r(e);var t=n(0),v=Object(t.a)({},function(){var a=this,e=a.$createElement,n=a._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"map类型"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#map类型","aria-hidden":"true"}},[a._v("#")]),a._v(" Map类型")]),a._v(" "),n("p",[a._v("Map"),n("T",[a._v("类型是内置的一个基本类型,表示哈希表。")])],1),a._v(" "),n("p",[a._v("字面量语法是{}表示空Map"),n("T",[a._v("，也可以用形如  { key1 = value1, key2 = value2, key3: value3, ['key4'] = value4, 'key5': value5, ... }的形式初始化一个table值。")])],1),a._v(" "),n("p",[a._v("Map"),n("T",[a._v("可以用点操作符或者中括号的方式修改和查询其中某个索引的值，比如:")])],1),a._v(" "),n("pre",[n("code",[a._v("let a = { name='uvm', age=1 }      -- 因为'uvm'和1的类型不一样，a变量的类型自动推导为Map<object>类型\nlet a1 = { name: 'uvm', age: 1 }   -- 这里a1和a两种初始化Map的方式等价\nlet a2 = { name: 'uvm', address: 'China' }   -- 因为'uvm'和'China'的类型都是string，所以a2变量的类型自动推导为Map<string>\nlet a3 = {name: 'uvm', 'age': 1 }   -- 这种方式和a，a1等价\na['abc'] = 'China'    -- 给a插入/修改索引’abc’对应的值\na.abc = 'China'    -- 效果同a['abc'] = 'China'\nlet b1 = a.name     -- 读取a的'name'索引对应的值赋值给新变量b1\nlet b2 = a['name']    -- 同 let b2 = a.name\n")])]),a._v(" "),n("p",[a._v("Map"),n("T",[a._v("类型的值的增删改查可以使用内置模块table模块来操作")])],1),a._v(" "),n("p",[a._v("例如:")]),a._v(" "),n("pre",[n("code",[a._v("var a = {name='uvm'}\nlet b1 = a.name  -- 获取哈希表a中的'name'这个key映射的值\nlet b2 = a['name']  -- 获取哈希表a中的'name'这个key映射的值的另一种方式\na.name = 'China'  -- 修改或增加哈希表a中'name'这个key映射为'China'\na['name'] = 'China'  -- 修改或增加哈希表a中'name'这个key映射为'China'的另一种方式\nvar k: string, v: string = '', ''\nfor k, v in pairs(a) do\n    pprint(k, v)  -- 遍历哈希表a，k和v分别是哈希表a的每一项的key和value\nend")])])])},[],!1,null,null,null);e.default=v.exports}}]);