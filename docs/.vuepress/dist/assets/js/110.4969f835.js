(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{364:function(e,t,n){"use strict";n.r(t);var a=n(0),r=Object(a.a)({},function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"howtos"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#howtos","aria-hidden":"true"}},[e._v("#")]),e._v(" HOWTOs")]),e._v(" "),n("h1",{attrs:{id:"_1-怎么进行调试"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-怎么进行调试","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. 怎么进行调试")]),e._v(" "),n("p",[e._v("默认情况下，合法的合约调用会在代理节点执行，但是普通节点也可以手动打开合约虚拟机，验证区块链中的合约调用，执行合约调用。")]),e._v(" "),n("p",[e._v("简单的调试方法可以通过pprint输出变量，对于基本类型pprint会输出多个参数值的字符串表示，\n对于函数会输出函数的内存地址，对于table类型的值会转成json字符串输出。")]),e._v(" "),n("p",[e._v("之后会增加远程调试功能，在远程代理节点上运行过程中断点调试。")]),e._v(" "),n("h1",{attrs:{id:"_2-怎么使用event"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-怎么使用event","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. 怎么使用event")]),e._v(" "),n("p",[e._v("合约中可以通过emit EventName(EventArg)抛出，EventName是自定义event名称，\nevent名称词法要求和变量名要求一样，但是最长支持49字符, EventArg是event的参数，要求值是最长1024字符的字符串")]),e._v(" "),n("p",[e._v("调用合约的操作执行过程中抛出的event，会被记录到区块链中，区块链本地节点可以设置监控某合约的某event的回调脚本，\n然后在区块链同步到包含被监控的event的块时，会触发设置的脚本，回调脚本也是用uvm编写。")]),e._v(" "),n("h1",{attrs:{id:"_3-常见编译错误有哪些"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_3-常见编译错误有哪些","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. 常见编译错误有哪些")]),e._v(" "),n("ul",[n("li",[e._v("变量类型和赋值不一致")]),e._v(" "),n("li",[e._v("函数调用的参数类型和实际传参类型不一致")]),e._v(" "),n("li",[e._v("函数参数类型和函数体中使用时的类型不一致，建议函数参数加上显式类型声明")]),e._v(" "),n("li",[e._v("一些代码块漏加 "),n("code",[e._v("end")])]),e._v(" "),n("li",[e._v("使用了没有申明过的变量")]),e._v(" "),n("li",[e._v("合约中定义了全局变量（合约中不允许定义新的全局变量只能读取，但是脚本中可以定义新全局变量）")]),e._v(" "),n("li",[e._v("对nil值进行一些不允许的操作符操作，比如加减乘除等")]),e._v(" "),n("li",[e._v("访问非table类型值的属性")]),e._v(" "),n("li",[e._v("其他")])]),e._v(" "),n("h1",{attrs:{id:"_4-对中文或者其他非英文的支持如何"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_4-对中文或者其他非英文的支持如何","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 对中文或者其他非英文的支持如何")]),e._v(" "),n("p",[e._v("变量名，函数名，event名称不可以使用中文，只能英文字符或者下划线开头，跟着若干个英文字符或者下划线或者数字，\n但是字符串中的内容可以用中文或者其他语言的文字，支持unicode。")]),e._v(" "),n("h1",{attrs:{id:"_5-支持多线程吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-支持多线程吗","aria-hidden":"true"}},[e._v("#")]),e._v(" 5. 支持多线程吗")]),e._v(" "),n("p",[e._v("因为uvm主要是为了在区块链的节点上运行的，考虑到区块链上的一些特性尤其是为了达成共识，不支持多线程编程")]),e._v(" "),n("h1",{attrs:{id:"_6-uvm中怎么使用随机数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_6-uvm中怎么使用随机数","aria-hidden":"true"}},[e._v("#")]),e._v(" 6. uvm中怎么使用随机数")]),e._v(" "),n("p",[e._v("提供两种获取随机数的方式")]),e._v(" "),n("ul",[n("li",[n("p",[e._v("全局函数get_chain_random()   获取链上伪随机数，这个函数返回的随机数是可被推算出来的结果，仅用于只需要返回均匀分布的数字的地方")])]),e._v(" "),n("li",[n("p",[e._v("全局函数get_waited(blocknumber)  可以获取根据指定块的块号上的二进制内容产生的一个int32数字，参数可以是过去块也可以是未来块的块号要用这种方式获取随机数，可以调用全局函数get_header_block_num()获取到前一个块的块号,\n然后用未来的某个块号（当前块号加上未来块的数量，大概10秒一个块）作为参数调用get_waited函数，如果执行的时候当前区块链还没有到这个块号，返回-1，\n如果执行的时候当前区块链已经超过了这个块号，返回根据那个块上数据产生的一个int32数字。以彩票为例，设置get_waited的参数为预计开奖时间的未来块号，\n然后在开奖前一段时间前允许投注，这时候get_waited参数的块号还没有到这个块，返回类型是-1，所有人都不知道到开奖时间后这个函数调用的返回结果会是多少。\n当开始时间到了后，调用get_waited的返回结果固定下来一个int32类型的正数，并且以后任何节点每次用同一个参数调用结果都是固定的，随机数被确定下来了。\n可以根据需要用这个返回值 (result % 10000) / 10000 来得到[0, 1)之间的精度4位小数的随机数")])])]),e._v(" "),n("h1",{attrs:{id:"_7-怎么实现面向对象的类型继承和多态"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-怎么实现面向对象的类型继承和多态","aria-hidden":"true"}},[e._v("#")]),e._v(" 7. 怎么实现面向对象的类型继承和多态")]),e._v(" "),n("p",[e._v("可以使用table类型和record类型模拟对象，record类型有默认属性值，并且属性可以是有默认实现的函数")]),e._v(" "),n("p",[e._v("比如")]),e._v(" "),n("pre",[n("code",[e._v('type Person = {\n    id: string default "123",\n    name: string default "uvm",\n    age ?: int = 24,  -- record属性默认值既可以用default也可以用=区分\n    fn: (number, number) => number default \n            function (a: number, b: number) \n                return a + b\n            end\n}\n\nlet p = Person()\npprint(p.id, p.name, p.age)\nlet n = p.fn(p.age, 2016)\npprint(n)\n')])]),e._v(" "),n("p",[e._v("如果需要实现类似面向对象语言中的类型继承和多态功能的话，可以实现一个extend函数，调用子record类型的构造函数后，用extend函数\n接受子对象和父类型，在extend函数中创建新的父类型的对象，然后给把父类型对象中子类型对象没有的属性赋值给子类型对象。用这种\n方法可以起到继承和多态的效果。目前没有给出标准的extend函数，给出一个示例实现")]),e._v(" "),n("pre",[n("code",[e._v("let function extend(obj, parent_class)\n    let parent = parent_class(obj)\n    for k, v in pairs(parent) do\n        obj[k] = v\n    return totable(obj)\nend\n\ntype A = {\n    name1: string,\n    age1: int default 100\n}\n\ntype B = {\n    name: string,\n    age: int\n}\n\nlet b = B()\nextend(b, A)\n\n-- or\n\nlet c = extend(B(), A)\n")])]),e._v(" "),n("p",[e._v("还有一种实现类型继承和多态的方法是使用setmetatable和元表，这以后会给出更多文档和例子")])])},[],!1,null,null,null);t.default=r.exports}}]);