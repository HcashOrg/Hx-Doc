(window.webpackJsonp=window.webpackJsonp||[]).push([[142],{323:function(a,e,t){"use strict";t.r(e);var s=t(0),r=Object(s.a)({},function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"storage操作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#storage操作","aria-hidden":"true"}},[a._v("#")]),a._v(" storage操作")]),a._v(" "),t("h1",{attrs:{id:"storage简单介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#storage简单介绍","aria-hidden":"true"}},[a._v("#")]),a._v(" storage简单介绍")]),a._v(" "),t("p",[a._v("每个智能合约在区块链中可以存储查询一些状态数据，这个功能称作storage。")]),a._v(" "),t("p",[a._v("在一个合约中的API函数中，可以用self.storage获取到当前合约的storage对象，import_contract加载的合约，禁止直接读写其storage")]),a._v(" "),t("p",[a._v("storage对象可以类似table操作，读取属性，写入属性，但是只能嵌套最多一层table，并且storage[某个属性名]值为某个类型的话，修改这个属性的值只能改为同类型的值，如果storage[某个属性名]值为table的话，这个table中不同属性的值的类型要一样，比如都是整数或者都是字符串。")]),a._v(" "),t("p",[a._v("对storage的修改操作不会立刻提交，而是在当前lua堆栈关闭的时候，如果没有发生过错误，就自动提交storage的变更（只提交变更而不是storage本身）")]),a._v(" "),t("h1",{attrs:{id:"storage的基本类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#storage的基本类型","aria-hidden":"true"}},[a._v("#")]),a._v(" storage的基本类型")]),a._v(" "),t("p",[a._v("storage中各属性的类型可以使用"),t("code",[a._v("int")]),a._v(", "),t("code",[a._v("number")]),a._v(", "),t("code",[a._v("bool")]),a._v(", "),t("code",[a._v("string")]),a._v(", "),t("code",[a._v("Stream")]),a._v(", "),t("code",[a._v("Map<int>")]),a._v(", "),t("code",[a._v("Map<number>")]),a._v(", "),t("code",[a._v("Map<bool>")]),a._v(", "),t("code",[a._v("Map<string>")]),a._v(",\n"),t("code",[a._v("Array<int>")]),a._v(", "),t("code",[a._v("Array<number>")]),a._v(", "),t("code",[a._v("Array<bool>")]),a._v(", "),t("code",[a._v("Array<string>")]),a._v("这些类型")]),a._v(" "),t("p",[a._v("storage操作比如：")]),a._v(" "),t("pre",[t("code",[a._v('self.storage.name = "hi"\nself.storage.age = 123\nself.storage.name = 456 -- 错误，类型不能改变\nlet abc = self.storage.age -- 正确，读取storage属性值\nself.storage.tt = {name: "hi", age: 2} -- 错误，嵌套table的属性值的类型要一样\nself.storage.tt = {name: {name: "hi"}} -- 错误，storage中嵌套table多层不允许\nself.storage.tt = {name: "hi", age: "2"} -- 正确\n')])]),a._v(" "),t("h1",{attrs:{id:"fast-map-storage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fast-map-storage","aria-hidden":"true"}},[a._v("#")]),a._v(" fast map storage")]),a._v(" "),t("p",[a._v("storage中的map/array类型会在使用时直接加载整个map/array到内存，只适用于较小的map/array。如果要使用较大的map/array，请使用fast map类型的storage")]),a._v(" "),t("p",[a._v("fast map类型的storage不直接在storage类型定义中定义，而是直接用"),t("code",[a._v("fast_map_get")]),a._v("和"),t("code",[a._v("fast_map_set")]),a._v("函数来读写。使用fast map来读写的时候，内存中只会加载访问的那一项，从而在fast map很大的时候也只需要占用较小的内存.")]),a._v(" "),t("p",[a._v("比如:")]),a._v(" "),t("pre",[t("code",[a._v("print(\"test_fastmap begin\")\n\nvar a1 = fast_map_get('balances', 'user1')\nprint(\"a1: \", a1)\n\nfast_map_set('balances', 'user1', 123)\nvar a2 = fast_map_get('balances', 'user1')\nprint(\"a2: \", a2)\n\n\nfast_map_set('balances', 'user1', 234)\nvar a3 = fast_map_get('balances', 'user1')\nprint(\"a3: \", a3)\n\nfast_map_set('balances', 'user2', 'world')\nvar b1 = fast_map_get('balances', 'user2')\nprint('b1: ', b1)\n\nfast_map_set('balances', 'user2', nil)\nvar b3 = fast_map_get('balances', 'user2')\nprint('b3: ', b3)\n\n\nfast_map_set('balances', 'user1', 'hello')\n\n\nvar a4 = fast_map_get('balances', 'user1')\nprint(\"a4: \", a4)\n\nprint(\"test_fastmap end\")\n")])])])},[],!1,null,null,null);e.default=r.exports}}]);